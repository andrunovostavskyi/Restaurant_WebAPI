2024-12-18 18:48:08.099 +02:00 [WRN] The entity type 'Adress' is an optional dependent using table sharing without any required non shared property that could be used to identify whether the entity exists. If all nullable properties contain a null value in database then an object instance won't be created in the query. Add a required property to create instances with null values for other properties or mark the incoming navigation as required to always create an instance.
2024-12-18 18:48:08.676 +02:00 [INF] Executed DbCommand (22ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "Restaurants" AS r)
2024-12-18 18:48:08.717 +02:00 [INF] Executed DbCommand (5ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "AspNetUserRoles" AS a)
2024-12-18 18:48:10.090 +02:00 [INF] HTTP GET /swagger/index.html responded 200 in 53.9308 ms
2024-12-18 18:48:10.105 +02:00 [INF] HTTP GET /swagger/index.js responded 200 in 2.4815 ms
2024-12-18 18:48:10.106 +02:00 [INF] HTTP GET /swagger/swagger-ui-bundle.js responded 304 in 5.9479 ms
2024-12-18 18:48:10.106 +02:00 [INF] HTTP GET /swagger/swagger-ui.css responded 304 in 5.9480 ms
2024-12-18 18:48:10.106 +02:00 [INF] HTTP GET /swagger/swagger-ui-standalone-preset.js responded 304 in 3.8104 ms
2024-12-18 18:48:10.106 +02:00 [INF] HTTP GET /swagger/index.css responded 304 in 5.9630 ms
2024-12-18 18:48:10.441 +02:00 [INF] HTTP GET /swagger/v1/swagger.json responded 200 in 112.7378 ms
2024-12-18 18:48:59.489 +02:00 [INF] Get all restaurants
2024-12-18 18:48:59.553 +02:00 [INF] Executed DbCommand (12ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:48:59.574 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:48:59.577 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:48:59.686 +02:00 [INF] Executed DbCommand (16ms) [Parameters=[@__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_0 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:48:59.715 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 339.0503 ms
2024-12-18 18:49:25.635 +02:00 [INF] Get all restaurants
2024-12-18 18:49:25.785 +02:00 [INF] Executed DbCommand (97ms) [Parameters=[@__filterPhaseLower_0_contains='?'], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
WHERE lower(r."Name") LIKE @__filterPhaseLower_0_contains OR lower(r."Description") LIKE @__filterPhaseLower_0_contains
2024-12-18 18:49:25.790 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:49:25.792 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:49:25.803 +02:00 [INF] Executed DbCommand (2ms) [Parameters=[@__filterPhaseLower_0_contains='?', @__p_1='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    WHERE lower(r."Name") LIKE @__filterPhaseLower_0_contains OR lower(r."Description") LIKE @__filterPhaseLower_0_contains
    LIMIT @__p_1 OFFSET @__p_1
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:49:25.808 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 243.2917 ms
2024-12-18 18:49:37.464 +02:00 [INF] Get all restaurants
2024-12-18 18:49:37.468 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:49:37.472 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:49:37.473 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:49:37.485 +02:00 [INF] Executed DbCommand (4ms) [Parameters=[@__p_1='?' (DbType = Int32), @__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_1 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:49:37.560 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 104.1187 ms
2024-12-18 18:54:49.745 +02:00 [WRN] The entity type 'Adress' is an optional dependent using table sharing without any required non shared property that could be used to identify whether the entity exists. If all nullable properties contain a null value in database then an object instance won't be created in the query. Add a required property to create instances with null values for other properties or mark the incoming navigation as required to always create an instance.
2024-12-18 18:54:50.241 +02:00 [INF] Executed DbCommand (15ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "Restaurants" AS r)
2024-12-18 18:54:50.276 +02:00 [INF] Executed DbCommand (2ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "AspNetUserRoles" AS a)
2024-12-18 18:54:50.968 +02:00 [INF] HTTP GET /swagger/index.html responded 200 in 41.5409 ms
2024-12-18 18:54:50.979 +02:00 [INF] HTTP GET /swagger/index.js responded 200 in 1.5155 ms
2024-12-18 18:54:51.187 +02:00 [INF] HTTP GET /swagger/favicon-32x32.png responded 304 in 3.2362 ms
2024-12-18 18:54:51.255 +02:00 [INF] HTTP GET /swagger/v1/swagger.json responded 200 in 93.5416 ms
2024-12-18 18:55:32.484 +02:00 [INF] Get all restaurants
2024-12-18 18:55:32.529 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:55:32.627 +02:00 [INF] Executed DbCommand (7ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:55:32.703 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:55:32.706 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:55:32.729 +02:00 [INF] Executed DbCommand (5ms) [Parameters=[@__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_0 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:55:32.752 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 366.6843 ms
2024-12-18 18:56:08.658 +02:00 [WRN] The entity type 'Adress' is an optional dependent using table sharing without any required non shared property that could be used to identify whether the entity exists. If all nullable properties contain a null value in database then an object instance won't be created in the query. Add a required property to create instances with null values for other properties or mark the incoming navigation as required to always create an instance.
2024-12-18 18:56:09.346 +02:00 [INF] Executed DbCommand (20ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "Restaurants" AS r)
2024-12-18 18:56:09.395 +02:00 [INF] Executed DbCommand (4ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "AspNetUserRoles" AS a)
2024-12-18 18:56:10.792 +02:00 [INF] HTTP GET /swagger/index.html responded 200 in 64.8115 ms
2024-12-18 18:56:10.804 +02:00 [INF] HTTP GET /swagger/index.js responded 200 in 2.7200 ms
2024-12-18 18:56:11.113 +02:00 [INF] HTTP GET /swagger/v1/swagger.json responded 200 in 120.2129 ms
2024-12-18 18:56:39.392 +02:00 [INF] Get all restaurants
2024-12-18 18:56:57.247 +02:00 [INF] Executed DbCommand (14ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:57:00.438 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:57:00.455 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:57:15.124 +02:00 [INF] Executed DbCommand (7ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:57:15.245 +02:00 [INF] Executed DbCommand (6ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:58:16.419 +02:00 [WRN] The entity type 'Adress' is an optional dependent using table sharing without any required non shared property that could be used to identify whether the entity exists. If all nullable properties contain a null value in database then an object instance won't be created in the query. Add a required property to create instances with null values for other properties or mark the incoming navigation as required to always create an instance.
2024-12-18 18:58:16.843 +02:00 [INF] Executed DbCommand (12ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "Restaurants" AS r)
2024-12-18 18:58:16.877 +02:00 [INF] Executed DbCommand (2ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "AspNetUserRoles" AS a)
2024-12-18 18:58:17.596 +02:00 [INF] HTTP GET /swagger/index.html responded 200 in 45.8194 ms
2024-12-18 18:58:17.607 +02:00 [INF] HTTP GET /swagger/index.js responded 200 in 2.2142 ms
2024-12-18 18:58:17.768 +02:00 [INF] HTTP GET /swagger/v1/swagger.json responded 200 in 81.0431 ms
2024-12-18 18:58:24.115 +02:00 [INF] Get all restaurants
2024-12-18 18:58:24.161 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:58:24.256 +02:00 [INF] Executed DbCommand (5ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:58:24.359 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 341.3321 ms
2024-12-18 18:58:39.753 +02:00 [INF] Get all restaurants
2024-12-18 18:58:39.796 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:58:39.802 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:58:39.811 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:58:39.814 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:58:39.843 +02:00 [INF] Executed DbCommand (9ms) [Parameters=[@__p_1='?' (DbType = Int32), @__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_1 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:58:39.851 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 113.3214 ms
2024-12-18 18:58:46.840 +02:00 [INF] Get all restaurants
2024-12-18 18:58:46.844 +02:00 [INF] Executed DbCommand (0ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:58:46.848 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:58:46.854 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:58:46.855 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 18:58:46.868 +02:00 [INF] Executed DbCommand (4ms) [Parameters=[@__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_0 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:58:46.873 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 41.1007 ms
2024-12-18 18:58:59.957 +02:00 [INF] Get all restaurants
2024-12-18 18:58:59.960 +02:00 [INF] Executed DbCommand (0ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:58:59.967 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:58:59.973 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[@__p_1='?' (DbType = Int32), @__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_1 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:58:59.977 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 19.9245 ms
2024-12-18 18:59:06.224 +02:00 [INF] Get all restaurants
2024-12-18 18:59:06.229 +02:00 [INF] Executed DbCommand (2ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:59:06.234 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:59:06.238 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[@__p_1='?' (DbType = Int32), @__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_1 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:59:06.242 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 17.8379 ms
2024-12-18 18:59:11.821 +02:00 [INF] Get all restaurants
2024-12-18 18:59:11.826 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 18:59:11.830 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 18:59:11.835 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[@__p_1='?' (DbType = Int32), @__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_1 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 18:59:11.838 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 17.3225 ms
2024-12-18 19:00:48.674 +02:00 [WRN] The entity type 'Adress' is an optional dependent using table sharing without any required non shared property that could be used to identify whether the entity exists. If all nullable properties contain a null value in database then an object instance won't be created in the query. Add a required property to create instances with null values for other properties or mark the incoming navigation as required to always create an instance.
2024-12-18 19:00:49.095 +02:00 [INF] Executed DbCommand (13ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "Restaurants" AS r)
2024-12-18 19:00:49.132 +02:00 [INF] Executed DbCommand (3ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT EXISTS (
    SELECT 1
    FROM "AspNetUserRoles" AS a)
2024-12-18 19:00:49.858 +02:00 [INF] HTTP GET /swagger/index.html responded 200 in 43.1297 ms
2024-12-18 19:00:49.868 +02:00 [INF] HTTP GET /swagger/index.js responded 200 in 1.3433 ms
2024-12-18 19:00:50.018 +02:00 [INF] HTTP GET /swagger/v1/swagger.json responded 200 in 79.8569 ms
2024-12-18 19:00:57.238 +02:00 [INF] Get all restaurants
2024-12-18 19:00:57.284 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 19:00:57.385 +02:00 [INF] Executed DbCommand (4ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 19:00:57.470 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 19:00:57.473 +02:00 [WRN] The query uses a row limiting operator ('Skip'/'Take') without an 'OrderBy' operator. This may lead to unpredictable results. If the 'Distinct' operator is used after 'OrderBy', then make sure to use the 'OrderBy' operator after 'Distinct' as the ordering would otherwise get erased.
2024-12-18 19:00:57.497 +02:00 [INF] Executed DbCommand (5ms) [Parameters=[@__p_1='?' (DbType = Int32), @__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_1 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 19:00:57.523 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 379.6361 ms
2024-12-18 19:01:14.116 +02:00 [INF] Get all restaurants
2024-12-18 19:01:14.159 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 19:01:14.164 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 19:01:14.170 +02:00 [INF] Executed DbCommand (1ms) [Parameters=[@__p_1='?' (DbType = Int32), @__p_0='?' (DbType = Int32)], CommandType='"Text"', CommandTimeout='30']
SELECT t."Id", t."Category", t."ContactEmail", t."ContactNumber", t."Description", t."HasDelivery", t."Name", t."OwnerId", t."Adress_City", t."Adress_PostalCode", t."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM (
    SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street"
    FROM "Restaurants" AS r
    LIMIT @__p_1 OFFSET @__p_0
) AS t
LEFT JOIN "Dishes" AS d ON t."Id" = d."RestaurantId"
ORDER BY t."Id"
2024-12-18 19:01:14.174 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 67.8650 ms
2024-12-18 19:38:24.288 +02:00 [INF] Get all restaurants
2024-12-18 19:38:24.380 +02:00 [INF] Executed DbCommand (39ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT count(*)::int
FROM "Restaurants" AS r
2024-12-18 19:38:24.391 +02:00 [INF] Executed DbCommand (7ms) [Parameters=[], CommandType='"Text"', CommandTimeout='30']
SELECT r."Id", r."Category", r."ContactEmail", r."ContactNumber", r."Description", r."HasDelivery", r."Name", r."OwnerId", r."Adress_City", r."Adress_PostalCode", r."Adress_Street", d."Id", d."Description", d."KiloCalories", d."Name", d."Price", d."RestaurantId"
FROM "Restaurants" AS r
LEFT JOIN "Dishes" AS d ON r."Id" = d."RestaurantId"
ORDER BY r."Id"
2024-12-18 19:38:24.402 +02:00 [INF] HTTP GET /api/Restaurant responded 200 in 122.0530 ms
